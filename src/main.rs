use axum::{
    extract::Extension,
    routing::get,
    Router,
};
use std::net::SocketAddr;
use tower_http::{
    request_id::{PropagateRequestIdLayer, RequestId},
    trace::{DefaultOnResponse, TraceLayer},
};
use tracing::Level;

// Use the logging module from the library crate
use axum_logging_service::logging;
use axum_logging_service::telemetry; // Added import
use axum_logging_service::error::AppError; // Import AppError
use axum::extract::Query; // To read query parameters
use serde::Deserialize; // To deserialize query parameters

// OpenTelemetry imports - Temporarily comment out problematic ones
// use axum_opentelemetry::middleware::{OtelAxumLayer, OtelInResponseLayer};
// use opentelemetry_prometheus::PrometheusExporter;
// use opentelemetry::global; // Keep this for global tracer/meter provider access - now unused
// use opentelemetry_sdk::metrics::MeterProvider as SdkMeterProvider;
// use prometheus::{Encoder, TextEncoder};
// Remove KeyValue as it's unused after commenting out Otel parts in handler
use opentelemetry::{Context as OtelContext, trace::TraceContextExt}; // Added for custom span events & context


#[tokio::main]
async fn main() {
    logging::init_subscriber(); // Initialize logging

    // Set the custom panic hook
    std::panic::set_hook(Box::new(telemetry::panic_hook));

    // Initialize OpenTelemetry Tracing - This now returns Err, logging.rs handles it by panicking.
    // For main, we'll just log the error and proceed without OTel specifics.
    if let Err(e) = telemetry::init_tracer() {
        tracing::warn!("Failed to initialize OpenTelemetry tracer (main): {:?}", e);
    }

    // Initialize OpenTelemetry Meter Provider - Temporarily disable related setup
    // let meter_provider = telemetry::init_meter_provider();
    // global::set_meter_provider(meter_provider.clone()); // Set the global meter provider

    // Setup Prometheus Exporter - Temporarily disable
    // let prometheus_exporter = opentelemetry_prometheus::exporter()
    //     .with_provider(meter_provider) // Use the SdkMeterProvider here
    //     .init();


    // Define the metrics route separately to not include OtelAxumLayer - Temporarily disable
    // let metrics_app = Router::new()
    //     .route("/metrics", get(metrics_handler).layer(Extension(prometheus_exporter.clone())));

    let app = Router::new()
        .route("/", get(handler))
        .route("/test_error", get(test_error_handler)) // New route
        .route("/test_panic", get(axum_logging_service::handlers::panic_handler)) // Route for intentional panic
        // OpenTelemetry layers - Temporarily disable
        // .layer(OtelAxumLayer::default()) // Captures trace for incoming requests
        // .layer(OtelInResponseLayer::default()) // Adds trace context to response headers
        // Layer to propagate X-Request-ID header or generate a new one
        // This should be AFTER OtelAxumLayer if OtelAxumLayer also generates or uses a request_id concept,
        // or if you want Otel to see the ID generated by PropagateRequestIdLayer.
        // For now, placing PropagateRequestIdLayer first to ensure it's available for logging.
        .layer(PropagateRequestIdLayer::x_request_id())
        // Layer to include the request_id in tracing spans (Logging)
        // This should be after PropagateRequestIdLayer to use its request_id
        // And after OtelAxumLayer to be within its trace
        .layer(
            TraceLayer::new_for_http()
                .make_span_with(|request: &axum::http::Request<_>| {
                    let request_id = request
                        .extensions()
                        .get::<RequestId>()
                        .and_then(|id| id.header_value().to_str().ok())
                        .map(ToString::to_string)
                        .unwrap_or_else(|| "unknown".into());
                    tracing::span!(
                        Level::INFO,
                        "http_request",
                        method = %request.method(),
                        uri = %request.uri(),
                        version = ?request.version(),
                        request_id = %request_id,
                    )
                })
                .on_response(DefaultOnResponse::new().level(Level::INFO)),
        );

    // Merge the main app with the metrics app - Temporarily disable
    // let app = app.merge(metrics_app);

    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    // tracing::info!("listening on {}", addr); // Listener will log its address
    let listener = tokio::net::TcpListener::bind(addr).await.unwrap();
    tracing::info!("listening on {}", listener.local_addr().unwrap());
    axum::serve(listener, app.into_make_service()).await.unwrap();
}

#[derive(Deserialize)]
struct HandlerParams {
    make_error: Option<bool>,
}

async fn handler(
    Extension(request_id_extension): Extension<RequestId>,
    Query(params): Query<HandlerParams>, // Read query parameters
) -> Result<String, AppError> { // Return Result<String, AppError>
    let request_id = request_id_extension
        .header_value()
        .to_str()
        .unwrap_or("unknown")
        .to_string();

    if params.make_error.unwrap_or(false) {
        tracing::info!("Simulating an error for request_id: {}", request_id);
        // Example of returning a BadRequest error
        return Err(AppError::BadRequest(format!("Triggered error for request_id: {}", request_id)));
    }

    let current_otel_cx = OtelContext::current();
    // let current_otel_span = current_otel_cx.span(); // Unused variable
    let _current_otel_span = current_otel_cx.span(); // Prefixed with underscore
    // Temporarily remove Otel specific context from handler
    // let current_otel_cx = OtelContext::current();
    // let current_otel_span = current_otel_cx.span();
    // current_otel_span.add_event(
    //     "Handler logic initiated".to_string(),
    //     vec![KeyValue::new("request_id", request_id.clone())]
    // );

    let greeting_message = "Hello, World!";
    let response_body = {
        let _custom_work_span_guard = tracing::info_span!(
            "custom_work_in_handler",
            service_operation = "generate_greeting",
            request_id = %request_id
        ).entered();
        tracing::info!("Performing custom work: generating greeting message for request_id: {}", request_id);
        format!("{} Request ID: {}", greeting_message, request_id)
    };

    // current_otel_span.add_event("Handler logic completed".to_string(), vec![]);
    tracing::info!("Request processing finished for request_id: {}", request_id);

    Ok(response_body) // Return Ok response
}

// New handler to specifically test error responses
async fn test_error_handler() -> Result<&'static str, AppError> {
    Err(AppError::InternalServerError)
}

// New handler for /metrics endpoint - Temporarily disable
// async fn metrics_handler(
//     Extension(exporter): Extension<PrometheusExporter>,
// ) -> (axum::http::StatusCode, axum::http::HeaderMap, String) {
//     let metric_families = exporter.registry().gather();
//     let mut buffer = Vec::new();
//     let encoder = TextEncoder::new();
//     if let Err(e) = encoder.encode(&metric_families, &mut buffer) {
//         tracing::error!("Failed to encode metrics: {:?}", e);
//         let mut headers = axum::http::HeaderMap::new();
//         headers.insert(axum::http::header::CONTENT_TYPE, encoder.format_type().parse().unwrap());
//         return (
//             axum::http::StatusCode::INTERNAL_SERVER_ERROR,
//             headers,
//             format!("Failed to encode metrics: {:?}", e),
//         );
//     }
//
//     let mut headers = axum::http::HeaderMap::new();
//     headers.insert(axum::http::header::CONTENT_TYPE, encoder.format_type().parse().unwrap());
//     (axum::http::StatusCode::OK, headers, String::from_utf8(buffer).unwrap())
// }

// Handler function to trigger a panic - MOVED to src/handlers.rs
// pub async fn panic_handler() -> &'static str {
//     panic!("This is a test panic from the /test_panic route!");
// }
