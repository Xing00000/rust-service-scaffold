use axum::{
    extract::Extension,
    routing::get,
    Router,
};
use std::net::SocketAddr;
use tower_http::{
    request_id::{PropagateRequestIdLayer, RequestId},
    trace::{DefaultOnResponse, TraceLayer},
};
use tracing::Level;

// Use the logging module from the library crate
use axum_logging_service::logging;
use axum_logging_service::telemetry; // Added import

// OpenTelemetry imports
use axum_opentelemetry::middleware::{OtelAxumLayer, OtelInResponseLayer};
use opentelemetry_prometheus::PrometheusExporter;
use opentelemetry::global; // Keep this for global tracer/meter provider access
use opentelemetry_sdk::metrics::MeterProvider as SdkMeterProvider; // Alias to avoid conflict if MeterProvider trait is in scope
use prometheus::{Encoder, TextEncoder};
use opentelemetry::{Context as OtelContext, KeyValue, trace::TraceContextExt}; // Added for custom span events & context


#[tokio::main]
async fn main() {
    logging::init_subscriber(); // Initialize logging

    // Initialize OpenTelemetry Tracing
    if let Err(e) = telemetry::init_tracer() {
        tracing::error!("Failed to initialize OpenTelemetry tracer: {:?}", e);
        // Depending on the application's needs, you might want to exit here
        // or proceed without tracing. For this example, we'll proceed.
    }

    // Initialize OpenTelemetry Meter Provider
    let meter_provider = telemetry::init_meter_provider();
    global::set_meter_provider(meter_provider.clone()); // Set the global meter provider

    // Setup Prometheus Exporter
    let prometheus_exporter = opentelemetry_prometheus::exporter()
        .with_provider(meter_provider) // Use the SdkMeterProvider here
        .init();


    // Define the metrics route separately to not include OtelAxumLayer
    let metrics_app = Router::new()
        .route("/metrics", get(metrics_handler).layer(Extension(prometheus_exporter.clone())));

    let app = Router::new()
        .route("/", get(handler))
        // OpenTelemetry layers
        .layer(OtelAxumLayer::default()) // Captures trace for incoming requests
        .layer(OtelInResponseLayer::default()) // Adds trace context to response headers
        // Layer to propagate X-Request-ID header or generate a new one
        // This should be AFTER OtelAxumLayer if OtelAxumLayer also generates or uses a request_id concept,
        // or if you want Otel to see the ID generated by PropagateRequestIdLayer.
        // For now, placing PropagateRequestIdLayer first to ensure it's available for logging.
        .layer(PropagateRequestIdLayer::x_request_id())
        // Layer to include the request_id in tracing spans (Logging)
        // This should be after PropagateRequestIdLayer to use its request_id
        // And after OtelAxumLayer to be within its trace
        .layer(
            TraceLayer::new_for_http()
                .make_span_with(|request: &axum::http::Request<_>| {
                    let request_id = request
                        .extensions()
                        .get::<RequestId>()
                        .and_then(|id| id.header_value().to_str().ok())
                        .map(ToString::to_string)
                        .unwrap_or_else(|| "unknown".into());
                    tracing::span!(
                        Level::INFO,
                        "http_request",
                        method = %request.method(),
                        uri = %request.uri(),
                        version = ?request.version(),
                        request_id = %request_id,
                    )
                })
                .on_response(DefaultOnResponse::new().level(Level::INFO)),
        );

    // Merge the main app with the metrics app
    let app = app.merge(metrics_app);

    let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    tracing::info!("listening on {}", addr);
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}

async fn handler(Extension(request_id_extension): Extension<RequestId>) -> String {
    let request_id = request_id_extension
        .header_value()
        .to_str()
        .unwrap_or("unknown")
        .to_string();

    // Add an event to the current request span (created by OtelAxumLayer)
    let current_otel_cx = OtelContext::current();
    let current_otel_span = current_otel_cx.span();
    current_otel_span.add_event(
        "Handler logic initiated".to_string(),
        vec![KeyValue::new("request_id", request_id.clone())]
    );

    let greeting_message = "Hello, World!";

    // Create a custom child span using tracing macros
    // This span will be a child of the request span from OtelAxumLayer
    let response_body = {
        let _custom_work_span_guard = tracing::info_span!(
            "custom_work_in_handler",
            service_operation = "generate_greeting", // Custom attribute for the span
            request_id = %request_id // Propagate request_id to child span's attributes
        ).entered(); // Enter the span, making it current for this block

        // Simulate some work inside the custom span
        tracing::info!("Performing custom work: generating greeting message for request_id: {}", request_id);
        // In a real app, this could be a database call or some business logic
        // tokio::time::sleep(std::time::Duration::from_millis(25)).await; // example delay

        format!("{} Request ID: {}", greeting_message, request_id)
    };

    current_otel_span.add_event("Handler logic completed".to_string(), vec![]);
    tracing::info!("Request processing finished for request_id: {}", request_id);

    response_body
}

// New handler for /metrics endpoint
async fn metrics_handler(
    Extension(exporter): Extension<PrometheusExporter>,
) -> (axum::http::StatusCode, axum::http::HeaderMap, String) {
    let metric_families = exporter.registry().gather();
    let mut buffer = Vec::new();
    let encoder = TextEncoder::new();
    if let Err(e) = encoder.encode(&metric_families, &mut buffer) {
        tracing::error!("Failed to encode metrics: {:?}", e);
        let mut headers = axum::http::HeaderMap::new();
        headers.insert(axum::http::header::CONTENT_TYPE, encoder.format_type().parse().unwrap());
        return (
            axum::http::StatusCode::INTERNAL_SERVER_ERROR,
            headers,
            format!("Failed to encode metrics: {:?}", e),
        );
    }

    let mut headers = axum::http::HeaderMap::new();
    headers.insert(axum::http::header::CONTENT_TYPE, encoder.format_type().parse().unwrap());
    (axum::http::StatusCode::OK, headers, String::from_utf8(buffer).unwrap())
}
